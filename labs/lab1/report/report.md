---
## Front matter
title: "Отчёт по лабораторной работе №1"
subtitle: "Математическое моделирование"
author: "Ищенко Ирина НПИбд-02-22"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Научиться использовать систему управления версиями git, освоить основные команды, применить на практике полученные знания [@mathmod].

# Выполнение лабораторной работы


Сначала проверяю имя пользователя и электронную почту. Приступаю к настройке `core.autocrlf`,  `core.safecrlf`, `core.quotepath`.

Создаю рабочий каталог с файлом `hello.html`. Добавляю запись. Создаю репозиторий и добавляю файл, проверяю текущее состояние. В репозитории хранится текущее состояние рабочего каталога, и нет никаких изменений, ожидающих записи (рис. [-@fig:1]).

![Настройка основных параметров git. Создание репозитория](image/1.png){#fig:1 width=70%}

Изменяю содержимое файла на `<h1>Hello, World!</h1>` (рис. [-@fig:2]). Проверяю состояние (git знает, что файл `hello.html` был изменен, но при этом эти изменения еще не зафиксированы в репозитории), индексирую изменения и вновь проверяю (изменения файла `hello.html` были проиндексированы. Это означает, что git теперь знает об изменении, но изменение пока не записано в репозиторий) (рис. [-@fig:3]).

![Изменение файла](image/2.png){#fig:2 width=70%}

![Название коммита](image/3.png){#fig:3 width=70%}

Делаю коммит изменений (рис. [-@fig:4]). Еще раз проверив статус, убеждаюсь, что рабочий каталог чистый.

![Внесение изменений и индексация, проверка статуса](image/4.png){#fig:4 width=70%}

Изменяю страницу «Hello, World!», чтобы она содержала стандартные теги (рис. [-@fig:5]).

![Добавление стандартных тегов](image/5.png){#fig:5 width=70%}

 Теперь добавляю это изменение в индекс git. В `hello.html` добавляю секцию `<head>` (рис. [-@fig:6]).

![Добавление заголовка](image/6.png){#fig:6 width=70%}
 
 Проверяю статус: `hello.html` указан дважды в состоянии. Делаю коммит индексированного изменения, просматриваю статус: осталось только непроиндексированное изменение. Индексирую и проверяю. Делаю еще один коммит (рис. [-@fig:7]).

![Внесение изменений, индексированние, коммит](image/7.png){#fig:7 width=70%}

Получаю историю изменений. Просматриваю в разных форматах (рис. [-@fig:8]).

![Просмотр истории](image/8.png){#fig:8 width=70%}
 
Изучаю данные лога и нахожу хэш для первого коммита. Использую этот хэш-код для получения старой версии. Возвращаюсь к последней версии. Создаю тег текущей версии (рис. [-@fig:9]).

![Получение старых версий](image/10.png){#fig:9 width=70%}

Создаю тег предыдущей версии и переключаюсь между ними, просматриваю теги (рис. [-@fig:10] и [-@fig:11]). Просматриваю теги в логе. Вижу теги (v1 и v1-beta) в логе вместе с именем ветки (master).
Кроме того HEAD показывает коммит, на который я переключился (на данный
момент это v1).

![Создание тега](image/11.png){#fig:10 width=70%}

![Просмотр тегов](image/12.png){#fig:11 width=70%}

Переключившись на ветку `master` изменяю файл (рис. [-@fig:12]).

![Изменение файла](image/13.png){#fig:12 width=70%}

Проверяю состояние:  файл `hello.html` был изменен, но еще не проиндексирован. Для переключения версии файла использую команды, проверяю статус, просматриваю файл (рис. [-@fig:13]).

![Отмена изменений до индексации](image/14.png){#fig:13 width=70%}

Вновь вношу изменений в файл (рис. [-@fig:14]).

![Изменение файла](image/15.png){#fig:14 width=70%}

Индексирую изменения. Выполняю сброс буферной зоны. Команда `git reset` сбрасывает буферную зону к HEAD. Это очищает буферную зону от изменений, которые мы только что проиндексировали. Использую команду `git checkout`, чтобы удалить нежелательные изменения в рабочем каталоге (рис. [-@fig:15]).

![Отмена изменений после индексации](image/16.png){#fig:15 width=70%}

Изменяю файл (рис. [-@fig:16]).

![Отмена изменений после индексации](image/17.png){#fig:16 width=70%}

Индексирую и коммичу изменение. Чтобы отменить коммит, необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом. Проверив лог, вижу оба коммита (рис. [-@fig:17]).

![Отмена изменений после коммита и проверка лога](image/18.png){#fig:17 width=70%}

Удаляю последние два коммита с помощью сброса, сначала отметив последний коммит тегом `oops`, чтобы его можно было потом найти. Использую команду `git reset`, чтобы вернуться к версии до этих коммитов. Теперь в логе их нет, но
если посмотретьлоги с опцией `--all` можно всё ещё их увидеть, но метка HEAD находится на нужной версии (рис. [-@fig:18] и [-@fig:19]).

![Сброс коммитов](image/19.png){#fig:18 width=70%}

![Просмотр лога](image/20.png){#fig:19 width=70%}

Удаляю тег и коммиты, на которые он ссылался, сборщиком мусора (рис. [-@fig:20]).

![Удаление тега и коммитов](image/21.png){#fig:20 width=70%}

Изменяю файл (рис. [-@fig:21]).

![Добавление имени](image/22.png){#fig:21 width=70%}

Индексирую изменения и делаю коммит. Добавляю в файл информацию об электронной почте (рис. [-@fig:22]).

![Добавление почты](image/23.png){#fig:22 width=70%}

Изменяю предыдущий коммит. Можно увидеть, что оригинальный коммит «автор» заменен коммитом «автор/email». Этого же эффекта можно достичь путем сброса последнего коммита в ветке, и повторного коммита новых изменений (рис. [-@fig:23]).

![Изменение коммита](image/24.png){#fig:23 width=70%}

Создаю каталог `lib` и перемещаю туда файл `hello.html` с помощью `git mv`. Делаю коммит, добавляю файл `index.html` (рис. [-@fig:24])  в репозиторий, делаю коммит (рис. [-@fig:25] и [-@fig:26]).

![Перемещение файла](image/25.png){#fig:24 width=70%}

![index.html](image/26.png){#fig:25 width=70%}

![Коммит](image/27.png){#fig:26 width=70%}

Теперь при открытии `index.html`, можно увидеть кусок страницы `hello` в
маленьком окошке.

Просматриваю данные из каталога `.git`, объектные файлы, ветки, теги и хэш (рис. [-@fig:27], [-@fig:28] и [-@fig:29]).

![Просмотр .git](image/28.png){#fig:27 width=70%}

![Просмотр .git](image/29.png){#fig:28 width=70%}

![Просмотр .git](image/30.png){#fig:29 width=70%}

Просматриваю файл `HEAD`, который  содержит ссылку на текущую ветку. Ищу последний коммит. Вывожу последний коммит с помощью SHA1 хэша, просматриваю дерево, каталог `lib`, файл `hello.html` (рис. [-@fig:29]).

![Просмотр по хэшу](image/31.png){#fig:30 width=70%}

Создаю ветку `style` и добавляю в `lib` файл стилей `style.css`:

```
h1 {
	color: red;
}
```

Индексирую и делаю коммит. Изменяю основную страницу, `index.html`, добавив поддержку стилей (рис. [-@fig:31]).

![Создание новой ветки и изменение файлов](image/33.png){#fig:31 width=70%}

В проекте теперье есть две ветки. Просматриваю лог, переключаюсь между ветками (рис. [-@fig:32],  [-@fig:33] и  [-@fig:34]).

![Просмотр файлов на двух ветках](image/35.png){#fig:32 width=70%}

![Просмотр файлов на двух ветках](image/36.png){#fig:33 width=70%}

![Просмотр файлов на двух ветках](image/37.png){#fig:34 width=70%}

Создаю `README.md` в ветке `master`, делаю коммит изменений. Просматриваю ветки и их отличия (рис. [-@fig:35]).

![Создание README.md в master](image/38.png){#fig:35 width=70%}

Слияние переносит изменения из двух веток в одну. Возвращаюсь к ветке
`style` и сливаю `master` с `style` и просматриваю ветки (рис. [-@fig:36]).

![Слияние `master` с `style` ](image/39.png){#fig:36 width=70%}

В ветке `master` изменяю `hello.html` (рис. [-@fig:37]).

![Изменение файла](image/40.png){#fig:37 width=70%}

Делаю коммит, просматриваю ветки, вижу конфликт (рис. [-@fig:38]) и (рис. [-@fig:39]).

![Создание конфликта ](image/42.png){#fig:38 width=70%}

![Конфликт в файле](image/43.png){#fig:39 width=70%}

 Возвращаюсь к ветке `style` и пытаюсь объединить ее с новой веткой `master`. В
 файле `lib/hello.html` можно увидеть записи с обеих версий этого файла. Первый
 раздел — версия текущей ветки (`style`). Второй раздел — версия ветки `master`.
 Вношу изменения в `lib/hello.html`, оставив только необходимую запись и
 добавляю этот файл в репозиторий, чтобы вручную разрешить конфликт (рис. [-@fig:40]) и (рис. [-@fig:41]).

![Разрешение конфликта](image/44.png){#fig:40 width=70%}

![Слияние](image/45.png){#fig:41 width=70%}

Вернемся на ветке `style` к точке перед тем, как мы слили ее с веткой `master`. Можно сбросить ветку к любому коммиту. По сути, это изменение указателя ветки
на любую точку дерева коммитов.
В этом случае мы хотим вернуться в ветке `style` в точку перед слиянием с `master`. Необходимо найти последний коммит перед слиянием. Сделаю сброс по хэшу и проверю (рис. [-@fig:42]).

![Сброс ветки style по хэшу](image/47.png){#fig:42 width=70%}

Аналогичным образом сбрасываю и эту ветку (рис. [-@fig:43]).

![Сброс ветки master по хэшу](image/49.png){#fig:43 width=70%}


Используем команду `rebase` вместо команды `merge`. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки `master` в нашу ветку `style` (рис. [-@fig:44]).

![Перебазирование](image/50.png){#fig:44 width=70%}

Выполняю слияние `style` в `master`. Просматриваю лог. Ветки идентичны (рис. [-@fig:45]).

![Слияние `style` в `master`](image/51.png){#fig:45 width=70%}

Создаю клон первоначального репозитория. Просматриваю его. Просматриваю лог клонированного репозитория. Отображаются все файлы и коммиты оригинального репозитория (рис. [-@fig:46]).

![Создание клона репозитория, просмотр файлов и коммитов](image/52.png){#fig:46 width=70%}

Просматриваю подробную информацию о ветках. Просматриваю доступные ветки, затем и удаленные. Git выводит все коммиты в оригинальный репозиторий, но ветки в удаленном
репозитории не рассматриваются как локальные. Если мы хотим собственную ветку
style, мы должны сами ее создать (рис. [-@fig:47]) и (рис. [-@fig:48]).

![Просмотр лога](image/53.png){#fig:47 width=70%}

![Просмотр веток в клоне](image/54.png){#fig:48 width=70%}

Перейдя в оригинальный репозиторий, изменяю README.md (рис. [-@fig:49]):

![Изменение файла](image/55.png){#fig:49 width=70%}

Добавляю изменение и делаю коммит.

Перехожу в клон и извлекаю изменения из оригинального репозитория. На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория (рис. [-@fig:50]).

![Извлечение изменений из оригинального репозитория](image/57.png){#fig:50 width=70%}

Просматриваю README.md. Произвожу слияние и проверяю, что файл на клоне обновился. Вместо извлечения и слияния можно было использовать одну команду: `git pull`. Добавляю локальную ветку, которая отслеживает удаленную ветку (рис. [-@fig:51]).

![Слияние извлеченных изменений. Ветка наблюдения](image/58.png){#fig:51 width=70%}

Создаю чистый репозиторий. Добавляю его к оригинальному репозиторию. В файл README.md вношу изменения. Добавляю изменения в `master` и делаю коммит. Отправляю изменения в общий репозиторий (рис. [-@fig:52]). Переключаюсь на клон и добавляю чистый репозиторий. С помощью `git pull shared master` извлекаю изменения. Просматриваю README.md  (рис. [-@fig:53]).

![Чистый репозиторий](image/59.png){#fig:52 width=70%}

![Чистый репозиторий. Добавление в оригинальный, отправка изменений в общий](image/60.png){#fig:53 width=70%}


# Выводы

В ходе выполнения работы я получила практические навыки использования системы управления версиями git.

# Список литературы{.unnumbered}

::: {#refs}
:::